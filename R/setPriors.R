#' Set up prior values for different categories of nodes
#'
#' Generates a list of custom specifications of priors for parameters in the model.
#' It is possible to set priors for a category of parameters (e.g. intercept,
#' coefficient, sd, factor, continuous) or to set a prior for a specific
#' parameter name (optionally including brackets with indices).
#' Exact name matches including brackets/indices are used first, followed by
#' name matches without indices, followed by data type (factor/continuous)
#' followed by parameter type (intercept/coefficient/sd).
#' Arguments can be supplied as quoted code or as character strings.
#'
#' @name setPriors
#' @author Ken Kellner
#' 
#' @param intercept Prior specification for intercepts
#' @param coefficient Prior specfication for slope coefficients
#' @param sd Prior specification for random effects SDs
#' @param factor Prior specifications for slope coefficients corresponding
#'  to factor data
#' @param continuous Prior specifications for slope coefficients corresponding
#'  to continuous data
#' @param ... Specific parameters, optionally with brackets/indices

#' @export
setPriors <- function(intercept = quote(dunif(-100, 100)),
                      coefficient = quote(dnorm(0, sd = 100)),
                      sd = quote(T(dt(0, 0.01, 1), 0,)),
                      factor = NULL,
                      continuous = NULL,
                      ...){
  # Get specific prior names
  extra <- list(...)
  # Combine everything
  out <- c(list(intercept = intercept, coefficient = coefficient, sd = sd,
                factor = factor, continuous = continuous), 
           extra)
  # Remove any null values
  out <- out[sapply(out, function(x) !is.null(x))]

  # Convert characters to code
  out <- lapply(out, function(x){
                  if(is.character(x)) return(str2lang(x)) else return(x)
                      })
  out
}

# Remove bracket from node
removeBracket <- function(node){
  if(!hasBracket(node)) return(node)
  node[[2]] 
}

#' Choose a prior from a list of prior settings
#'
#' Attempts to determine which prior to put on a parameter based on a list of settings,
#' such as the output from setPriors(). The function follows the following
#' search pattern: (1) looks for an exact match to the parameter name including brackets;
#' (2) a match to the parameter name without brackets; (3) goes through each value
#' supplied to \code{...} in order and looks for a match in the names of the
#' settings list. Once a match is found the function returns the corresponding
#' prior value.
#'
#' @name choosePriorFromSettings
#' @author Ken Kellner
#' 
#' @param parName Parameter to get a prior for, as quoted code/name, possibly
#'  including brackets/indices
#' @param ... Character strings that categorize the parameter and match
#'  the names of elements in \code{priorSettings}. The order is important:
#'  the first match found is used.
#' @param priorSettings A named list of prior settings, e.g. as generated by
#'  \code{setPriors}
#'
#' @export
choosePriorFromSettings <- function(parName, ..., priorSettings){
  
  # 1. If exact prior name is specified in priors
  par_char <- deparse(parName)
  possible_prior <- priorSettings[[par_char]]
  if(!is.null(possible_prior)){
    checkValidPrior(possible_prior)
    return(possible_prior)
  }

  # 2. If prior name without brackets is specified
  par_nobracks <- deparse(removeBracket(parName))
  possible_prior <- priorSettings[[par_nobracks]]
  if(!is.null(possible_prior)){
    checkValidPrior(possible_prior)
    return(possible_prior)
  }
  
  # 3. Other possible categories in ..., in order
  par_types <- list(...)
  for (i in par_types){
    if(is.null(i) || is.na(i)) next
    if(i %in% names(priorSettings)){
      if(is.null(priorSettings[[i]])) next
      checkValidPrior(priorSettings[[i]])
      return(priorSettings[[i]])
    }
  }
  stop("Unable to set prior for parameter ", parName, call.=FALSE)
}

checkValidPrior <- function(prior){
  if(!(is.call(prior) | is.name(prior))) stop("Invalid prior ", prior, call.=FALSE)
  invisible()
}
