#' Set up prior values for different categories of nodes
#'
#' Generates a list of custom specifications of priors for parameters in the model.
#' It is possible to set priors for a category of parameters (e.g. intercept,
#' coefficient, sd, factor, continuous) or to set a prior for a specific
#' parameter name (optionally including brackets with indices).
#' Exact name matches including brackets/indices are used first, followed by
#' name matches without indices, followed by data type (factor/continuous)
#' followed by parameter type (intercept/coefficient/sd).
#' Arguments can be supplied as quoted code or as character strings.
#'
#' @name setPriors
#' @author Ken Kellner
#' 
#' @param intercept Prior specification for intercepts
#' @param coefficient Prior specfication for slope coefficients
#' @param sd Prior specification for random effects SDs
#' @param factor Prior specifications for slope coefficients corresponding
#'  to factor data
#' @param continuous Prior specifications for slope coefficients corresponding
#'  to continuous data
#' @param ... Specific parameters, optionally with brackets/indices

#' @export
setPriors <- function(intercept = quote(dunif(-100, 100)),
                      coefficient = quote(dnorm(0, sd = 100)),
                      sd = quote(T(dt(0, 0.01, 1), 0,)),
                      factor = NULL,
                      continuous = NULL,
                      ...){
  # Get specific prior names
  extra <- list(...)
  # Combine everything
  out <- c(list(intercept = intercept, coefficient = coefficient, sd = sd,
                factor = factor, continuous = continuous), 
           extra)
  # Remove any null values
  out <- out[sapply(out, function(x) !is.null(x))]

  # Convert characters to code
  out <- lapply(out, function(x){
                  if(is.character(x)) return(str2lang(x)) else return(x)
                      })
  out
}

# Remove bracket from node
removeBracket <- function(node){
  if(!hasBracket(node)) return(node)
  node[[2]] 
}

#' Choose a prior from a list of prior settings
#'
#' Attempts to determine which prior to put on a parameter based on a list of settings,
#' such as the output from setPriors(). The function follows the following
#' search pattern: (1) looks for an exact match to the parameter name including brackets;
#' (2) a match to the parameter name without brackets; (3) goes through each value
#' supplied to \code{...} in order and looks for a match in the names of the
#' settings list. Once a match is found the function returns the corresponding
#' prior value.
#'
#' @name findPrior
#' @author Ken Kellner
#' 
#' @param parName Parameter to get a prior for, as quoted code/name, possibly
#'  including brackets/indices
#' @param ... Character strings that categorize the parameter and match
#'  the names of elements in \code{priorSettings}. The order is important:
#'  the first match found is used.
#' @param priorSettings A named list of prior settings, e.g. as generated by
#'  \code{setPriors}
#'
#' @export
findPrior <- function(parName, ..., priorSettings){
  
  # 1. If exact prior name is specified in priors
  par_char <- deparse(parName)
  possible_prior <- priorSettings[[par_char]]
  if(!is.null(possible_prior)) return(possible_prior)

  # 2. If prior name without brackets is specified
  par_nobracks <- deparse(removeBracket(parName))
  possible_prior <- priorSettings[[par_nobracks]]
  if(!is.null(possible_prior)) return(possible_prior)
  
  # 3. Other possible categories in ..., in order
  par_types <- list(...)
  for (i in par_types){
    if(is.null(i) || is.na(i)) next
    if(i %in% names(priorSettings)){
      return(priorSettings[[i]])
    }
  }
  stop("Unable to set prior for parameter ", parName, call.=FALSE)
}

# Generate a code block with parameter priors for a given formula and 
# corresponding dataset
# Fixes some parameter values at 0 if necessary (i.e., reference levels for factors)
#' @importFrom stats model.matrix
makeFixedPriorsFromFormula <- function(formula, data, priors, prefix, modMatNames=FALSE){ 

  par_struct <- makeParameterStructure(formula, data)
  # Matching structure with the model matrix version of the names
  # Plugged in later if modMatNames = TRUE
  par_mm <- makeParameterStructureModMatNames(formula, data)

  par_names <- getParametersForLP(names(par_struct), prefix)

  data_types <- sapply(names(par_struct), function(x, data){
    if(x == "Intercept") return(NULL)
    if(is.factor(data[[x]])) return("factor")
    "continuous"
  }, data = data)

  par_types <- ifelse(names(par_struct) == "Intercept", "intercept", "coefficient")

  all_priors <- lapply(1:length(par_struct), function(i){

    # Get all inds - they should be only 0 or 1 so <2 captures all
    inds <- as.matrix(which(par_struct[[i]] < 2, arr.ind=TRUE))
  
    if(nrow(inds) < 2){
      node <- str2lang(par_names[i])
      # Search in order: parameter name exactly, without brackets, data type, parameter type
      prior <- findPrior(node, data_types[[i]], par_types[i], priorSettings=priors)
      return(substitute(LHS ~ PRIOR, list(LHS=node, PRIOR=prior)))
    }

    lapply(1:nrow(inds), function(j){
      val <- par_struct[[i]][t(inds[j,])]
      bracket <- paste0("[",paste(inds[j,], collapse=","),"]")
      node <- str2lang(paste0(par_names[i], bracket))
      if(val){
        if(modMatNames){
          alt_par <- str2lang(paste0(prefix, par_mm[[i]][t(inds[j,])]))
          prior <- findPrior(alt_par, data_types[[i]], par_types[i], priorSettings=priors)
          embedLinesInCurlyBrackets(
            list(substitute(LHS <- ALT, list(LHS=node, ALT=alt_par)),
                 substitute(ALT ~ PRIOR, list(ALT=alt_par, PRIOR=prior)))
          )
        } else {
          prior <- findPrior(node, data_types[[i]], par_types[i], priorSettings=priors)
          substitute(LHS ~ PRIOR, list(LHS=node, PRIOR=prior))
        }
      } else {
        substitute(LHS <- 0, list(LHS=node))
      }
    })
  })
  all_priors <- unlist(all_priors)
  # unroll interior brackets
  all_priors <- unlist(lapply(all_priors, function(x){
    if(x[[1]] == "{") x <- as.list(x)[2:length(x)]
    x
  }))
  
  list(code=embedLinesInCurlyBrackets(all_priors), parameters=par_names)
}

# Organize model.matrix() version of parameter names into an
# identical data structure to makeParameterStructure()
# So they can be matched if required
#' @importFrom stats model.matrix
makeParameterStructureModMatNames <- function(formula, data){
 
  # Generate placeholder structure containing all 0s
  empty_structure <- makeEmptyParameterStructure(formula, data)

  pars_full <- colnames(model.matrix(formula, data))
  pars_sep <- strsplit(pars_full, ":")
  pars_full <- gsub("(","", pars_full, fixed=TRUE)
  pars_full <- gsub(")", "", pars_full, fixed=TRUE)
  pars_full <- gsub(":", ".", pars_full, fixed=TRUE)
  
  # Replace elements of parameter structure for which we actually estimate
  # a parameter with 1
  lapply(empty_structure, function(x){
    for (i in 1:length(pars_sep)){
      ind <- t(pars_sep[[i]])
      if(length(dim(x)) == length(ind) & all(ind %in% unlist(dimnames(x)))){
        x[ind] <- pars_full[i]
      }
    }
    drop(x)
  })
}

#' Macro to build code for priors on a linear predictor from R formula
#'
#' Generates appropriate priors for a linear predictor derived from an 
#' R formula. As such it makes the most sense to use this macro together with
#' the linPred macro which takes similar arguments.
#'
#' @name priors
#' @author Ken Kellner
#'
#' @param formula An R formula The formula must be right-hand side only (e.g. ~x). 
#'  This must always be the first argument supplied to priors.
#' @param coefPrefix All model coefficient names will begin with this prefix.
#'  default is beta_ (so x becomes beta_x, etc.)
#' @param sdPrefix All dispersion parameters will begin with this prefix.
#'  default is no prefix.
#' @param priorSettings List of prior specifications, should be generated using 
#'  setPriors()
#' @param modMatNames Logical, should parameters be named so they match the
#'  names you would get from R's model.matrix function?
#' @param indicators If TRUE, add priors for indicator variables
#'
#' @examples
#' \donttest{
#' constants <- list(x = rnorm(10), 
#'                   x2 = factor(sample(letters[1:3], 10, replace=TRUE)))
#'
#' # Just linear predictor
#' code <- nimbleCode({
#'   y[1:n] ~ linPred(~x + x2)
#'   priors(~x + x2, coefPrior = dnorm(0, sd = 5), modMatNames=TRUE)
#'  })
#' nimble:::processModelMacros(code, constants)$code
#' }
NULL

#' @importFrom lme4 nobars
#' @export

priors <- nimble::model_macro_builder(
function(form, coefPrefix=quote(beta_), sdPrefix=NULL, priorSettings=setPriors(), 
         modMatNames=FALSE, indicators=FALSE, modelInfo, .env){

  if(form[[1]] != quote(`~`)) form <- c(quote(`~`),form) 
  form <- as.formula(form)
  form <- removeBracketsFromFormula(form)
  
  priorSettings <- eval(priorSettings, envir=.env) 

  rand_info <- processAllBars(form, priorSettings, coefPrefix, sdPrefix, modelInfo) 
    
  new_form <- form
  if(!is.null(rand_info$formula)){
    new_form <- addFormulaTerms(list(lme4::nobars(form), rand_info$formula))
    new_form <- as.formula(new_form)
  }

  dat <- makeDummyDataFrame(new_form, modelInfo$constants)

  fixed <- makeFixedPriorsFromFormula(lme4::nobars(form), dat, priorSettings, 
                               prefix=as.character(deparse(coefPrefix)),
                               modMatNames = modMatNames)
  out <- list(fixed$code)
  if(indicators){
    ind_priors <- indicatorVarPriors(lme4::nobars(form), dat, coefPrefix)
    out <- c(out, list(ind_priors))
  }
  if(!is.null(rand_info$code)) out <- c(out, list(rand_info$code))
  out <- embedLinesInCurlyBrackets(out)
  out <- removeExtraBrackets(out)
  
  #parameters <- c(parameters, list(priors=findDeclarations(out)))
  list(code=out, modelInfo=modelInfo)
},
use3pieces=FALSE,
unpackArgs=TRUE
)

isTilde <- function(code){
  code[[1]] == "~"
}

findPriors <- function(code, index=NULL){
  out <- lapply(1:length(code), function(i){
    index <- paste0(index, "[[", i, "]]")
    if(code[[i]] == "{"){
      return(NULL)
    } else if(code[[i]][[1]] == "for"){
      unlist(findPriors(code[[i]][[4]], index=paste0(index, "[[4]]")), recursive=FALSE)
    } else {
      if(isTilde(code[[i]])){
        return(list(par=getLHS(code[[i]]), index=index))
      } else {
        return(NULL)
      }
    }
  })
  out[!sapply(out, function(x) is.null(x[[1]]))]
}

replaceCode <- function(code, index, newValue){

  codebrack <- str2lang(paste0("code", index))

  run <- substitute(CODEBRACK[[3]] <- quote(NEWVAL),
                    list(CODEBRACK=codebrack, NEWVAL=newValue))
  eval(run)
  code
}

modifyPrior <- function(code, parameter, newPrior){  
  pr <- findPriors(code)
  if(is.character(newPrior)){
    newPrior <- str2lang(newPrior)
  }
  if(is.character(parameter)){
    parameter <- str2lang(parameter)
  }
  pars <- lapply(pr, function(x) x$par)
  indices <- lapply(pr, function(x) x$index)
  idx <- which(parameter == pars)
  if(length(idx) != 1){
    stop("No prior for ",deparse(parameter)," found", call.=FALSE)
  }

  replaceCode(code, indices[idx], newPrior) 

}

findDeclarations <- function(code){
  out <- lapply(1:length(code), function(i){
    if(code[[i]] == "{"){
      return(NULL)
    } else if(code[[i]][[1]] == "for"){
      return(findDeclarations(code[[i]][[4]]))
    } else {
      if(isAssignment(code[[i]])){
        return(getLHS(code[[i]]))
      } else {
        return(NULL)
      }
    }
  })
  out <- out[!sapply(out, is.null)]
  out <- lapply(out, function(x){
    if(hasBracket(x)) return(x[[2]]) else return(x)
  })
  unlist(out[!duplicated(out)])
}

indicatorVarPriors <- function(formula, data, prefix){
  formula_nobrack <- removeBracketsFromFormula(formula)
  par_struct <- makeParameterStructure(formula_nobrack, data)
  n_zbeta <- as.numeric(length(names(par_struct)[names(par_struct)!="Intercept"]))
  z_name <- str2lang(paste0("z_", deparse(prefix)))
  psi_name <- str2lang(paste0("psi_", deparse(prefix)))

  substitute({
    PSI ~ dunif(0, 1)
    ZNAME[1:NZ] ~ forLoop(dbern(PSI))
    }, list(ZNAME=z_name, NZ=n_zbeta, PSI=psi_name)
  )
}
